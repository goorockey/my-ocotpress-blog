{% if site.github_user %}
<script type="text/javascript">
    (function () {
        var jxhr = document.createElement('script');
        jxhr.type = 'text/javascript';
        jxhr.src = '{{ root_url}}/javascripts/libs/jXHR.js';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(jxhr, s);

var github = (function(){
    function render(target, repos){
        var i = 0, fragment = '', t = $(target)[0];

        for(i = 0; i < repos.length; i++) {
            fragment += '<li><a href="'+repos[i].html_url+'">'+repos[i].name+'</a><p>'+repos[i].description+'</p></li>';
        }
        t.innerHTML = fragment;
    }
    return {
        showRepos: function(options){
            $.ajax({
                url: "https://api.github.com/users/"+options.user+"/repos?"
                , type: 'jsonp'
                , error: function (err) { $(options.target + ' li.loading').addClass('error').text("Error loading feed"); }
            , success: function(data) {

                var repos = [];
                if (!data.data) { return; }
                for (var i = 0; i < data.data.length; i++) {
                    if (options.skip_forks && data.data[i].fork) { continue; }
                    repos.push(data.data[i]);
                }
                repos.sort(function(a, b) {
                    var aDate = new Date(a.pushed_at).valueOf(),
                    bDate = new Date(b.pushed_at).valueOf();

                if (aDate === bDate) { return 0; }
                return aDate > bDate ? -1 : 1;
                });

                if (options.count) { repos.splice(options.count); }
                render(options.target, repos);
            }
            });
        }
    };
})();

        github.showRepos({
            user: '{{site.github_user}}',
            count: {{site.github_repo_count}},
            skip_forks: {{site.github_skip_forks}},
            target: '#gh_repos'
        });
    }());
</script>
{% endif %}
