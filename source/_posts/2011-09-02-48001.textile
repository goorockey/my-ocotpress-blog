---
layout: post
title: '《Windows核心编程》读书笔记1--内核对象'
date: 2011-9-2
wordpress_id: 48001
permalink: /blogs/48001
comments: true
category: windows
---
<span style="color: #ffff00;"><strong><span style="color: #c0c0c0; font-size: large;">一、摘要</span></strong></span>

<span style="color: #ffff00;"><span style="color: #ff0000;">1、内核对象有使用计数，当计数减为0时，内核对象被销毁。</span></span>

<span style="color: #ffff00;"><span style="color: #ff0000;">2、内核对象有安全描述符，控制该进程能做的操作。</span></span>

<span style="color: #ffff00;"><span style="color: #ff0000;">3、每个进程内有内核对象句柄表，记录使用中的内核对象。</span></span>

<span style="color: #ffff00;"><strong> </strong></span>

<span style="color: #ffff00;"><strong><span style="color: #c0c0c0; font-size: large;">二、内核对象</span></strong></span>

<span style="color: #ffff00;"><strong><span style="color: #ff0000;">1、对内核对象的操作,只能通过调API</span></strong></span>

（1）应用程序无法在内存中找到表示内核对象的数据结构,也就无法直接修改其状态。

（2）要对内核对象操作，只能先获得其句柄，然后调用window定义好的API<!--more-->

<span style="color: #ffff00;"><strong><span style="color: #ff0000;">2、内核对象的使用计数，记录在使用它的进程数</span></strong></span>

（1）内核对象是属于内核的，而不属于任何一个进程，包括创建它的哪个进程。

（2）内核对象中有一个使用计数的数据，记录在使用它的进程数。

（3）只有当使用计数为零时，该内核对象才会被销毁。

（4）即使创建它的进程终止了，该内核对象的使用计数不为零就不会被销毁。

<span style="color: #ffff00;"><strong><span style="color: #ff0000;">3、内核对象的安全描述符，控制进程对其的使用权</span></strong></span>

（1）在创建内核对象的API中，都有一个“安全描述符”的参数，是用来控制对这个内核对象的使用权的

例如创建文件内存映射CreateFileMapping就有一个PSECURITY_ATTRIBUTES的参数。

（2）而在获取该内核对象的API OpenFileMapping中，会有一个表征获取该对象做什么操作的参数。

如果该用户允许对该内核对象做该操作，则成功返回该内核对象句柄，否则返回NULL

（3）分辨一个对象是否为内核对象的标志是，创建该对象的API是否有“安全描述符”这个参数。

如创建GDI就没有该参数，所以GDI不是内核对象

<span style="color: #ffff00;"><strong><span style="color: #ff0000;">4、进程的内核对象句柄表，记录使用的内核对象</span></strong></span>

内核对象句柄表结构：
<table width="563" border="1" cellspacing="0" cellpadding="2">
<tbody>
<tr>
<td valign="top" width="102">索引
(Handle)</td>
<td valign="top" width="159"><span style="color: #ff8080;">内核对象内存块的指针</span></td>
<td valign="top" width="150">访问屏蔽
（标志位的DWORD）</td>
<td valign="top" width="150">继承标志
（标志位的DWORD ）</td>
</tr>
<tr>
<td valign="top" width="102">1</td>
<td valign="top" width="159">0 x ? ? ? ? ? ? ? ?</td>
<td valign="top" width="150">0 x ? ? ? ? ? ? ? ?</td>
<td valign="top" width="150">0 x ? ? ? ? ? ? ? ?</td>
</tr>
<tr>
<td valign="top" width="102">2</td>
<td valign="top" width="159">0 x ? ? ? ? ? ? ? ?</td>
<td valign="top" width="150">0 x ? ? ? ? ? ? ? ?</td>
<td valign="top" width="150">0 x ? ? ? ? ? ? ? ?</td>
</tr>
<tr>
<td valign="top" width="102">…</td>
<td valign="top" width="159">…</td>
<td valign="top" width="151">…</td>
<td valign="top" width="151">…</td>
</tr>
</tbody>
</table>
（1）每个进程内都有一个内核对象句柄表来记录它在使用的内核对象，表中包含该内核对象内存块的指针。

在内核对象的句柄就是该内核对象在此表中的索引值。

（2）创建内核对象时，会在表中寻找空白项，并添加新项，并通过该内核对象指针对它的使用计数置1.

（3）用CloseHandle释放进程对该内核对象使用权时，就通过该指针对使用计数减1

（4）即使没有用CloseHandle，当进程终止时，会对句柄表中没有释放使用权的内核对象计数减1

<span style="color: #ffff00;"><strong><span style="color: #ff0000;">5、进程间访问内核对象</span></strong></span>

（1）设置子进程继承父进程的内核对象

（2）创建有名字的内核对象，并通过内核对象名字访问它。

（3）DuplicateHandle 复制内核对象

<strong><span style="color: #ff0000;">6、当用Create*（如CreateMutex）创建有名字的内核对象</span></strong>

（1）如果<span style="color: #ff8080;">同名字</span>、<span style="color: #ff8080;">同类</span>的内核对象已存在，则返回该内核对象的Handle；

（2）如果<span style="color: #ff8080;">同名字</span>、<span style="color: #ff8080;">不同类</span>的内核对象已存在，则创建失败，并返回NULL

（3）如果没有同名字的内核对象存在，则创建新内核对象
