<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[categories: network | Goorockey's Blog]]></title>
  <link href="http://www.goorockey.com/blog/categories/network/atom.xml" rel="self"/>
  <link href="http://www.goorockey.com/"/>
  <updated>2014-03-06T09:52:01+08:00</updated>
  <id>http://www.goorockey.com/</id>
  <author>
    <name><![CDATA[Goorockey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用VMWare组网，实验DNS隧道]]></title>
    <link href="http://www.goorockey.com/blogs/77254"/>
    <updated>2012-03-15T00:00:00+08:00</updated>
    <id>http://www.goorockey.com/blogs/77254</id>
    <content type="html"><![CDATA[<p>继续用VMWare来组网，这次要测试我想试很久的DNS隧道，之前碍于没有找到有独立ip的方法（当然是要免费的~~），现在用VMWare就可以了。</p>

<p>DNS隧道是什么就不解释了。google一下DNS隧道能搜到风河、云风两个大牛相关的blog。这次我用iodine来实现DNS隧道。</p>

<!--more-->
<h6><strong /> </h6>
<h6><strong>1、场景</strong> </h6>
<p>现在情况是，用户只能跟外界有DNS通路，想借此进行平常的http、ftp等通信。</p>

<p>据说平常的CMCC等开放热点，虽然http等要账号和密码，但DNS是通的，然后你懂的了。</p>

<p> </p>

<p>简单的拓扑图如下：</p>

<p><a href="http://www.goorockey.com/uploads/2012/03/image2.png"><img style="display: inline; border: 0px;" title="image" src="http://www.goorockey.com/uploads/2012/03/image_thumb2.png" alt="image" width="454" height="306" border="0" /></a></p>

<p>整个回路就是：</p>
<ul>
	<li>用户把要想跟外网进行通信的数据包用DNS协议封装</li>
	<li>得到的DNS包发送给DNS服务器，要求做DNS解析</li>
	<li>DNS服务器根据域名，解析出DNS代理的ip，并把数据包发给它</li>
	<li>DNS代理把数据包解封，并转发给外网的目标地址</li>
	<li>外网回复的数据包原路返回，这样就完成通讯了。</li>
</ul>
<p><strong /> </p>
<h6><strong>2、VMWare环境模拟</strong></h6>
<p>这次我用了三台机子，系统还是CentOS 6.0：</p>

<p> <strong>主机名 <strong>角色 <strong>网卡ip</strong></strong></strong></p>

<p>HostA   用户 192.168.149.128 (Host-only)</p>

<p>HostB   DNS代理 192.168.126.130 (NAT)</p>

<p>HostC   DNS服务器 192.168.149.130 (Host-only)、192.168.126.233 (NAT)</p>

<p> </p>

<p>要模拟的初始状态就是：</p>
<ul>
	<li>HostA（用户）可以跟HostC做DNS解析，但不能访问外网 。     （所以虚拟网卡用Host-only模式）</li>
	<li>HostB（DNS代理）可以跟外网通信。            （用NAT和Bridged都可以，这次我选用NAT）</li>
	<li>HostC（DNS服务器）可以跟HostA进行DNS解析，且能跟HostB通信。   （所以用两张网卡，为了分别跟HostA和HostB通信）</li>
	<li>HostA的iptables不允许HostA和HostB之间互访</li>
</ul>
<p> </p>
<h6><strong>3、DNS服务器配置</strong></h6>
<p>刚开始看教程好像很繁琐，感觉conf文件好多啊，而且配置项也多~~</p>

<p>静下心来看，其实要实现最基本的的DNS解析很简单，主要就是修改两个文件。</p>

<p> </p>

<p><strong>（1）安装</strong></p>

<p>需要在HostC执行以下命令，安装DNS服务器所需的bind和caching-nameserver：</p>
<blockquote><span style="color: #222222;">$ yum install –y bind bind-utils bind-chroot caching-nameserver</span></blockquote>
<p><strong /> </p>

<p><strong>（2）修改named的conf文件（/etc/named.conf）</strong></p>

<p>添加域名goorockey.go域名的配置：</p>
<blockquote><span style="color: #222222;">zone “goorockey.go” IN {</span>

<span style="color: #222222;">        type   master;</span>

<span style="color: #222222;">        file      “goorockey.go.zone”;</span>

<span style="color: #222222;">         allow-update {none; };</span>

<span style="color: #222222;">}</span></blockquote>
<p>大概解释：</p>
<ul>
	<li>zone “ goorockey.go”： 指示要添加goorockey.go这个域名的正向解析。正向解析就是指域名到ip的解析，反向解析是指ip到域名的解析。例如想通过查询DNS服务器，知道192.168.0.1判定了多少域名，则在DNS服务器上配置zone “1.0.168.192.in-addr-arpa”的项。</li>
	<li>type master：对于goorockey.go这个域名，当前DNS服务器是它的主DNS服务器。type可以还可以使hint和slave。只有zone “.”可以配置type hint。type slave是指对于这个域名，当前DNS服务器是辅助DNS服务器，即它的DNS记录是从主服务器拷贝过来的，目的是为了达到DNS解析的分布式、负载均衡。</li>
	<li>file “goorockey.go.zone”：这个域名的DNS记录文件在goorockey.go.zone，文件所在目录在/etc/named.conf的options项中的directory来定义。默认是/var/named</li>
	<li>allow-update：定义时候允许更新</li>
</ul>
<p> </p>

<p>要注意的是，/etc/named.conf中的options项是所有域名的全局配置。默认时，有：</p>
<blockquote>allow-query   {   localhost;   };</blockquote>
<p>意思是只允许本机做DNS查询，当然要把它注释掉。</p>
<blockquote>listen-port    53    {  127.0.0.1;   };</blockquote>
<p>意思是服务端口为53，但监听的ip是127.0.0.1，这样就不能让别的机子访问DNS解析服务了。所以可以把这句话注释掉，或者把ip改为0.0.0.0或指定ip。</p>

<p> </p>

<p><strong>（3）编辑goorockey.go的DNS记录文件</strong></p>

<p>根据我们在/etc/named.conf的配置，文件是/var/named/goorockey.go.zone。</p>

<p>创建此文件，并编辑内容为：</p>
<blockquote><span style="color: #222222;">@  IN   SOA   localhost.    root.localhost.      (  20120315   3600  1800  36000  3600  )</span>

<span style="color: #222222;">     IN    NS      localhost.</span>

<span style="color: #222222;">goorockey.go   IN   A    192.168.126.130</span></blockquote>
<p>大概解释：</p>
<ul>
	<li>第一行是一条SOA记录。@指代当前域名，就是/etc/named中的goorockey.go。SOA记录是域名有效性的相关属性。localhost.是主服务器的地址。root.localhost.是邮箱。主要DNS记录文件的地址都用FQDN，每个地址最后的句号“.”表示结束。如果没有句号“.”，会自动追加域名，例如没有句号的localhost会解释成”localhost.goorockey.go“。后面就是具体属性项。</li>
	<li>第二行开始是两个空格，第一个空格表示继续上一条的内容，这里指”@“，第二个空格就是分割@和IN的。这一行表示域名goorockey.go的域名服务器是本机。</li>
	<li>第三行是一条A记录，A for address。意思就是域名goorockey.go会解析成ip 192.168.126.130。可以看出，搞这么久，就是为了找到这句话。所以说A记录是DNS服务器的核心，就是它标明DNS解析的。</li>
</ul>
<p> </p>

<p>DNS记录类型还会有：</p>
<ul>
	<li>PTR用在反向解析</li>
	<li>MX用在邮件服务器</li>
	<li>TXT就是纯文本，对DNS服务器做标注</li>
</ul>
<p> </p>

<p><strong>（4）运行DNS服务</strong></p>

<p>在HostC执行：</p>
<blockquote><span style="color: #222222;">$ service  named   start</span></blockquote>
<p>或者</p>
<blockquote><span style="color: #222222;">$ /etc/init.d/named start</span></blockquote>
<p>这就可以运行DNS服务了。</p>

<p> </p>

<p>对HostC的/etc/resolv.conf添加 nameserver 127.0.0.1</p>

<p>则在HostC用nslookup能成功返回DNS信息：</p>

<p><a href="http://www.goorockey.com/uploads/2012/03/20594453.png"><img style="display: inline; border: 0px;" title="20594453" src="http://www.goorockey.com/uploads/2012/03/20594453_thumb.png" alt="20594453" width="471" height="132" border="0" /></a></p>

<p> </p>

<p>但还要配置iptables，使其他机子可以访问DNS服务的端口。</p>

<p>对于默认的53端口，在HostC运行：</p>
<blockquote><span style="color: #222222;">$ iptables    –I  INPUT  -p  tcp   --dport 53   -j   ACCEPT</span>

<span style="color: #222222;">$ iptables   –I  INPUT  -p  udp   --dport 53   -j  ACCEPT</span></blockquote>
<p>要解释一下的是，DNS包有可能以tcp或者udp方式传输。一般首选是udp方式。但因为udp包长度只能是512字节，也不能分包，所以如果当DNS包长度大于512时，就会选择tcp方式。所以这里要对tcp和udp都设置ACCEPT。</p>

<p>在HostA和HostB的/etc/resolv.conf添加HostA的ip后，就能正确解析goorockey.go了。</p>

<p> </p>
<h6><strong>4、iodine</strong></h6>
<p>iodine是外国人写的开源DNS隧道工具，有linux版、windows版和Mac版的。</p>

<p>教程看它的ReadMe或者HowToSetup都比较清楚。</p>

<p>下载并安装对应自己版本的iodine后就能使用了。</p>

<p> </p>

<p>在DNS隧道的服务器端(HostB)，先执行：</p>
<blockquote><span style="color: #222222;">$ iodined   -f    10.0.0.1   goorockey.go</span></blockquote>
<p><span style="color: #222222;">输入密码后，服务端就运行了。注意服务端运行的是iodined，有”d“。</span></p>

<p> </p>

<p>在客户端（HostA)，执行：</p>
<blockquote><span style="color: #222222;">$ iodine   -f  -c  192.168.126.130 goorockey.go</span></blockquote>
<p>其中192.168.126.130是服务端（HostB）的ip。</p>

<p>然后还要配置一下，HostA，HostB，HostC的iptables，使它们的DNS包可以通过就可以了。</p>

<p> </p>

<p>这时候，HostA的虚拟网卡ip是10.0.0.2，HostB的虚拟网卡ip是10.0.0.1。两台机子已经建立了VPN。</p>

<p>本来两台不能互访的机子就可以访问了。</p>

<p>例如在HostA就可以ssh HostB了 ：</p>
<blockquote><span style="color: #222222;">$ ssh 10.0.0.1</span></blockquote>
<p> 然后就可以用ssh隧道过去来做代理了~~</p>

<p> </p>
<h6><strong>5、小结</strong></h6>
<p>那时候看到DNS隧道，真是非常的兴奋，感觉太爽、太妙了。其实协议都可以这样做隧道，只是那时候没有意识到而已。</p>

<p>之后还继续想实验一下ICMP隧道，看一下iodine的代码。O(∩_∩)O哈哈~</p>

<p> </p>
<h6><strong>参考资料：</strong></h6>
<ul>
	<li>【风河的博文】<a title="http://www.nsbeta.info/archives/96" href="http://www.nsbeta.info/archives/96">http://www.nsbeta.info/archives/96</a></li>
	<li>【云风的博文】<a title="http://blog.codingnow.com/2011/06/dns_tunnel.html" href="http://blog.codingnow.com/2011/06/dns_tunnel.html">http://blog.codingnow.com/2011/06/dns_tunnel.html</a></li>
	<li>【iodine】<a title="http://code.kryo.se/iodine/" href="http://code.kryo.se/iodine/">http://code.kryo.se/iodine/</a></li>
</ul>
<p> </p>

<p> </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VMWare组网实验(NAT)]]></title>
    <link href="http://www.goorockey.com/blogs/77247"/>
    <updated>2012-03-13T00:00:00+08:00</updated>
    <id>http://www.goorockey.com/blogs/77247</id>
    <content type="html"><![CDATA[<p>本着“干中学”的精神，看完资料，还是用VMWare来练习一下使用NAT，好加深认识。</p>

<p>实验涉及：NAT，iptables，</p>

<p> </p>

<!--more-->
<h6><strong>1、实验目标</strong></h6>
<p>这次我要用iptables实现NAT功能（SNAT和DNAT）。</p>

<p>先上拓扑图（可能有点不规范）：</p>

<p><a href="http://www.goorockey.com/uploads/2012/03/image.png"><img style="display: inline; border: 0px;" title="image" src="http://www.goorockey.com/uploads/2012/03/image_thumb.png" alt="image" width="405" height="273" border="0" /></a></p>

<p>如图分别有4台机子：A、B在内网，但在不同的网段中，C做网关，控制网段间的访问。D在外网。</p>

<p>要达到：</p>
<ul>
	<li>A、B能通信（内网不同网段的互访）</li>
	<li>A、B能通过C与外网通信</li>
	<li>D能通过C访问到A、B的服务</li>
</ul>
<p> </p>
<h6><strong>2、环境</strong></h6>
<p>用VMWare虚拟出这4台机子，VMWare的版本为8.0</p>

<p>每台机子都跑CentOS 6.0</p>

<p> </p>

<p> </p>
<h6><strong>3、</strong>VMWare环境配置</h6>
<p>安装4个虚拟机，都装上CentOS，主机名分别定为hostA、hostB、hostC、hostD，对应A、B、C、D。</p>

<p>VMWare新建几张网卡（菜单栏【edit】-【Virtual Network Editor】），要求一张为Bridged（NAT应该也行），两张为Host-only。
&lt;p align="left"&gt;<a href="http://www.goorockey.com/uploads/2012/03/151306312.png"><img style="display: inline; border: 0px;" title="151306312" src="http://www.goorockey.com/uploads/2012/03/151306312_thumb.png" alt="151306312" width="680" height="128" border="0" /></a>&lt;/p&gt;
设置A、B网卡分别为VMnet1和VMnet2，这是为了使它们原始都不能互访。</p>

<p>外网的D网卡设为VMnet0</p>

<p>C则有三张网卡VMnet0、VMnet1、VMnet2，这样C原始都能访问到A、B、D。</p>

<p> </p>

<p>然后进入每个虚拟机，为了方便，我都设置为静态ip（网段跟上图对应）：</p>
<blockquote>A：192.168.149.128

B：192.168.214.128

C：192.168.4.233（eth0），192.168.149.130（eth1），192.168.214.130（eth2）

D：192.168.4.234</blockquote>
<p>CentOS里面配置网卡方法就是修改/etc/sysconfig/network-scripts/ifcfg-eth*，没有则自己创建一个。</p>

<p>关键项就是ONBOOT，IPADDR，NETMASK，GATEWAY，DNS1，DNS2，PEERDNS</p>

<p> </p>

<p>要注意的是，有PEERDNS项，当它值为yes，则会把DNS1和DNS2覆盖地写入/etc/resolv.conf。</p>

<p>这对于多网卡的C，如果ifcfg-eth0、ifcfg-eth1、ifcfg-eth2都设了PEERDNS，由于开机是按名字的顺序执行，则会把ifcfg-eth2的DNS写入/etc/resolv.conf，前两个文件的DNS会无效了的。所以我只在ifcfg-eth0配置PEERDNS=“yes“。</p>

<p> </p>

<p>好，初步网络环境配置完成。</p>

<p>现在情况是：</p>
<ul>
	<li>ABD都不能互访，因为在不同的网段</li>
	<li>C则都能跟它们三个互访</li>
</ul>
<p> </p>

<p> </p>
<h6><strong>4、配置网关C的iptables，实现NAT</strong></h6>
<p>到关键也是好玩的地方了。</p>

<p>接下来配置网关C的iptables，实现不同网络间地址的转换（NAT）。</p>

<p>iptables内容比较多，详细可以参考：<a title="http://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html" href="http://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html">http://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html</a></p>

<p> </p>

<p><strong>（1）A、B通过C实现通信</strong></p>

<p>这个比较简单，没用到iptables，把A的网关设为C的对应网卡的ip（192.168.149.130），B的网关设为C对应网卡的ip（192.168.214.130）。</p>

<p>然后打开C的ip转发，在C中执行：</p>
<blockquote><span style="color: #222222;">$ echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span></blockquote>
<p>这就把C作为了A、B的网关。A、B间通信的数据包会发到C，靠C的网卡间转发来完成通信。AB就可以相互ping通了。</p>

<p> </p>

<p><strong>（2）A、B通过C与外网通信（SNAT）</strong></p>

<p>现在A、B都不能跟D通信，因为现在A、B发到D的数据包源地址（192.168.149.128,192.168.214.128），D是无法知道的（D在C的同一个网络，网关设为相同的ip）。则包可以发到D，但D回复不了，因为它的网关不知道A、B。</p>

<p>现在就通过SNAT把A、B发送的包在经过C时，把源地址改为C的外网ip（192.168.4.233），这个D是知道的，也就可以顺利回复了。</p>

<p>具体在C中执行：</p>
<blockquote><span style="color: #222222;">$ iptables     –t   nat     –A  POSTROUTING     –o  eth0     –j SNAT  -–to-source  192.168.4.233</span></blockquote>
<p>这样A、B就能ping通了。</p>

<p>SNAT可以看看<a href="http://www.goorockey.com/2012/03/11/77213">我的博文</a>。(<em>^__^</em>) 嘻嘻……</p>

<p> </p>

<p><strong>（3）D通过C访问A、B的服务（DNAT）</strong></p>

<p>现在A、B可以跟D通信，但D不能主动访问A、B。还是因为D只知道C，不知道A、B。</p>

<p>假如现在A开了19991口的sshd：</p>

<p>在A的/etc/ssh/sshd_config中添加：</p>
<blockquote>ListenAddress 0.0.0.0:19991</blockquote>
<p>重启sshd</p>
<blockquote><span style="color: #222222;">$ service sshd restart</span></blockquote>
<p>在A中让iptables允许对19991口的访问</p>
<blockquote><span style="color: #222222;">$ iptables     –I   INPUT       -p tcp   --dport 19991    - j ACCEPT </span></blockquote>
<p> </p>

<p>现在D想ssh到A的19991，则可以在C中执行以下命令，实现DNAT：</p>
<blockquote><span style="color: #222222;">$ iptables    -t nat   -A   PREROUTING    -p  tcp   --dport  19991  -j   DNAT   --to-destination   192.168.149.128</span></blockquote>
<p>现在D可以通过ssh到C的19991口来ssh到A了。</p>

<p> </p>

<p> </p>
<h6><strong>5、小结</strong></h6>
<p>整个实验搞完，对iptables，NAT的原理还是深刻了不少。</p>

<p>然后，就是VMWare是个好东西。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NAT学习总结]]></title>
    <link href="http://www.goorockey.com/blogs/77213"/>
    <updated>2012-03-11T00:00:00+08:00</updated>
    <id>http://www.goorockey.com/blogs/77213</id>
    <content type="html"><![CDATA[<p>最近要恶补一下计算机网络的基础知识，今天先总结一下NAT。</p>

<p> </p>
<h6><strong>1、NAT的背景</strong></h6>
<p>随着Internet的普及，网络中的ip资源是越来越紧张。而NAT就是为了解决这个问题的方案。</p>

<p>NAT是Network Address Translation,网络地址转换，会在网关中实现局域网内部ip和外网ip之间转换。<!--more-->
&lt;p style="text-align: center;"&gt;<a href="http://www.goorockey.com/uploads/2012/03/nat_1.png"><img class="alignnone  wp-image-77214" title="nat_1" src="http://www.goorockey.com/uploads/2012/03/nat_1.png" alt="" width="303" height="194" /></a>&lt;/p&gt;
如上图，局域网内部网段是192.168.1.X，这些ip只在这个局域网内有意义，外网无法根据这些ip定位计算机。</p>

<p>而NAT就是做内网和外网这样两个网络间的ip转换。</p>

<p> </p>

<p> </p>
<h6><strong>2、NAT的类型</strong></h6>
<p>按照通信发起方的不同，NAT可以分为：</p>
<ul>
	<li>SNAT，即Source NAT</li>
	<li>DNAT，即Destination NAT</li>
</ul>
<p> </p>

<p><strong>（1）SNAT</strong></p>

<p>SNAT是对数据包源ip的转换，主要用于内网机子发起连接到外网的情况。</p>

<p>【考虑以下场景】：</p>

<p>内网ip为192.168.1.2的机子向外网的8.8.8.8发包。如果数据包的源ip直接就是192.168.1.2，数据包虽然可以成功到达8.8.8.8，但是它无法根据192.168.1.2的源ip回复数据包，因为在外网中没有192.168.1.2，则造成通信失败。</p>

<p>而SNAT就是当内网发起连接到外网时，具有NAT功能的机子，例如网关，在数据包要出外网之前，把包的源ip改为这个局域网的外网ip，如1.1.1.1，同时会有映射表记录转换。</p>

<p>由于1.1.1.1是外网中有意义的ip，1.1.1.1和8.8.8.8可以成功的完成数据包的发送和接受。这时8.8.8.8是把1.1.1.1作为目标ip回复数据包，网关收到数据包后，会查表把包的目标ip映射回内网机子ip 192.168.1.2。</p>

<p>可以看出来，整个过程对内网机子是透明的，即发送和接受数据包的ip都对应，仿佛没有做过转换。</p>

<p> </p>

<p><strong>（2）DNAT</strong></p>

<p>DNAT是对数据包目标ip的转换，主要用于外网向内网发起连接的情况。</p>

<p>【考虑一下场景】：</p>

<p>在内网中有很多机子，其中有一台ip为192.168.1.2的机子是对外网提供服务的web服务器，现在外网的8.8.8.8要访问它。但对于8.8.8.8来说，web服务器所在ip会是192.168.1.2所在内网的外网ip，如1.1.1.1。</p>

<p>可想而知，当8.8.8.8向1.1.1.1发送数据包，网关会做DNAT，把包的目标ip从1.1.1.1改为192.168.1.2，同时会把转换记录到一个表中。然后192.168.1.2回复数据包，包的源ip是192.168.1.2，目标ip会是8.8.8.8。网关接受到包后，则查表，把源ip修改回1.1.1.1。</p>

<p> </p>

<p> </p>
<h6><strong>3、NAT的转换方式</strong></h6>
<p>NAT有四种转换方式：</p>
<ul>
	<li>静态NAT  (Static NAT)</li>
	<li>动态NAT  (Dynamic NAT)</li>
	<li>过载        (Overload NAT)</li>
	<li>重叠        (Overlap NAT)</li>
</ul>
<p><strong>（1）Static NAT</strong></p>

<p><a href="http://www.goorockey.com/uploads/2012/03/nat-static.jpg"><img class="wp-image-77216 aligncenter" title="nat-static" src="http://www.goorockey.com/uploads/2012/03/nat-static.jpg" alt="" width="317" height="102" /></a></p>

<p>局域网有多个外网ip，数量等于或多于内网ip数。</p>

<p>则做NAT转换时，每个内网ip对应一个外网ip。</p>

<p>网关的表中记录着这样一对一的关系。</p>

<p> </p>

<p><strong>（2）Dynamic NAT</strong></p>

<p><a href="http://www.goorockey.com/uploads/2012/03/nat-dynamic.jpg"><img class="wp-image-77217 aligncenter" title="nat-dynamic" src="http://www.goorockey.com/uploads/2012/03/nat-dynamic.jpg" alt="" width="331" height="147" /></a></p>

<p>局域网有多个外网ip，但数量少于内网ip数。</p>

<p>则做转换时，每个内网ip从当前未被映射的外网ip选取一个来做转换。</p>

<p>网关的表也会记录这种转换，且会根据情况不断更新。</p>

<p> </p>

<p><strong>（3）Overload NAT</strong></p>

<p><a href="http://www.goorockey.com/uploads/2012/03/nat-overload.jpg"><img class="wp-image-77218 aligncenter" title="nat-overload" src="http://www.goorockey.com/uploads/2012/03/nat-overload.jpg" alt="" width="360" height="117" /></a></p>

<p>如果局域网只有一个外网ip，每个内网ip都映射到这个外网ip，但端口口会不同。</p>

<p>网关的表中会记录这种端口的映射。</p>

<p> </p>

<p><strong>（4）Overlap NAT</strong></p>

<p><a href="http://www.goorockey.com/uploads/2012/03/nat-overlap.jpg"><img class="wp-image-77220 aligncenter" title="nat-overlap" src="http://www.goorockey.com/uploads/2012/03/nat-overlap.jpg" alt="" width="360" height="126" /></a></p>

<p>当内网的ip在外网中已经注册且已被其他机子使用时，网关要在选择一个外网中已注册但未被使用的ip做转换。</p>

<p>网关的表中记录这种转化。</p>

<p> </p>

<p> </p>
<h6><strong>4、小结</strong></h6>
<p>其实所谓的内网和外网都是相对而言，只要是两个网络间的通信，都可以或需要用网关或路由做NAT。</p>

<p> </p>

<p> </p>

<p>【参考资料】：</p>
<ul>
	<li><span><a class="smarterwiki-linkify" href="http://article.yeeyan.org/view/185403/150856">http://article.yeeyan.org/view/185403/150856</a></span></li>
	<li><span><a class="smarterwiki-linkify" href="http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">http://zh.wikipedia.org/wiki/网络地址转换</a></span></li>
</ul>
<p> </p>

<p> </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH端口转发]]></title>
    <link href="http://www.goorockey.com/blogs/77141"/>
    <updated>2012-02-22T00:00:00+08:00</updated>
    <id>http://www.goorockey.com/blogs/77141</id>
    <content type="html"><![CDATA[<h4><strong>1、ssh端口转发是什么</strong></h4>
<p>ssh端口转发也被叫ssh隧道，ssh代理。</p>

<p>所谓隧道，就是用X协议封装Y协议的数据包，靠X协议来进行Y协议通信。</p>

<p>总的来说ssh隧道提供了两个好处：</p>
<ul>
	<li>突破防火墙等，进行受限协议的通信。</li>
	<li>使如telnet等不安全的协议传输经过ssh的加密通道，提高安全性。</li>
</ul>
<!--more-->
<h4><strong>2、三种ssh端口转发</strong></h4>
<p>ssh端口转发有三种：</p>
<ul>
	<li>本地转发</li>
	<li>远程转发</li>
	<li>动态转发</li>
</ul>
<p> </p>
<h6>(1) 本地转发</h6>
<p>命令是：</p>
<blockquote><span style="color: #222222;">$ ssh –L &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;ssh host&gt;</span></blockquote>
<p>考虑这样的场景：</p>

<p><a href="http://www.goorockey.com/uploads/2012/02/image002.jpg"><img style="background-image: none; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="image002" src="http://www.goorockey.com/uploads/2012/02/image002_thumb.jpg" alt="image002" width="410" height="287" border="0" /></a></p>

<p>一个运行在服务器116.1.1.1的程序提供端口389的数据通信，但防火墙只允许其他计算机对服务器做ssh的通信。</p>

<p>而客户端116.4.0.1为了完成通信，可以借助ssh的本地端口转发。</p>

<p>在客户端执行：</p>
<blockquote><span style="color: #222222;">$ ssh –L  7001:localhost:389     116.1.1.1</span></blockquote>
<p>同时把客户端程序输出到本机的7001端口。注意命令中的localhost是相对于116.1.1.1来说的。</p>

<p>那么整个数据流会是：</p>
<ul>
	<li>客户端程序到数据输出到客户端的7001口</li>
	<li>客户端的ssh一直检测7001口，但发现本机有数据包到达，则把数据包加密，并通过跟服务端116.1.1.1的ssh通路传输</li>
	<li>服务端的sshd收到数据包后包解密，并转发到服务端的389口</li>
	<li>服务端返回数据，并原路返回</li>
</ul>
<p> </p>

<p>另外，在ssh本地转发命令中的remote host可以使任意的机子，包括本机或其他计算机。</p>

<p>例如，考虑这样的场景，用本地转发来进行远程桌面：</p>

<p><a href="http://www.goorockey.com/uploads/2012/02/image.png"><img style="background-image: none; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="image" src="http://www.goorockey.com/uploads/2012/02/image_thumb.png" alt="image" width="244" height="202" border="0" /></a></p>

<p>现在要在机子A对机子C做远程桌面。但机子A和机子C都在不同的子网，不能直接通信，也都只能跟机子B用ssh通信。</p>

<p>然后已知windows远程桌面的服务端端口是3389，这我们可以在机子A执行：</p>
<blockquote><span style="color: #222222;">$ssh –L   13389:&lt;C hostname&gt;:3389     &lt;B hostname&gt;</span></blockquote>
<p>命令中的13389是任意的，但要注意只有管理员才能用1~1024的端口。</p>

<p>然后在A机子执行yuan远程桌面：</p>
<blockquote><span style="color: #222222;">mstsc /v:13389</span></blockquote>
<p>就能在A机子远程桌面控制C机子了。</p>

<p> </p>
<h6>(2) 远程转发</h6>
<p>其实远程转发跟本地转发是基本相同的。</p>

<p>命令是：</p>
<blockquote><span style="color: #222222;">$ ssh –R  &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt;    &lt;ssh host&gt;</span></blockquote>
<p>考虑这样的场景：</p>

<p><a href="http://www.goorockey.com/uploads/2012/02/image003.jpg"><img style="background-image: none; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="image003" src="http://www.goorockey.com/uploads/2012/02/image003_thumb.jpg" alt="image003" width="383" height="258" border="0" /></a></p>

<p>客户端A和服务端B的端口都还是7001和389。</p>

<p>跟本地转发时候不同的是，ssh连接的sshd在客户端A，ssh在服务端B。</p>

<p>所以，远程转发可以应用在客户端A只允许对其做ssh连接的时候。</p>

<p>如果客户端和服务端都允许ssh连接，那选择本地转发还是远程转发都可以。</p>

<p> </p>
<h6>(3) 动态转发</h6>
<p>命令是：</p>
<blockquote><span style="color: #222222;">$ ssh –D &lt;local port&gt;  &lt;ssh host&gt;</span></blockquote>
<p><a href="http://www.goorockey.com/uploads/2012/02/image005.jpg"><img style="background-image: none; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="image005" src="http://www.goorockey.com/uploads/2012/02/image005_thumb.jpg" alt="image005" width="345" height="226" border="0" /></a></p>

<p>跟其他两种端口转发不同的是，动态转发在数据包经过ssh通过到达服务端后，sshd会根据把封装数据包的协议，转发到对应的主机和端口。</p>

<p>这时候ssh隧道是充当了SOCKS代理的作用。这就可以用来翻X之类了。</p>

<p> </p>
<h4><strong>3、Ending</strong></h4>
<p>总的来说，ssh是个好东西~~~</p>

<p> </p>

<p> </p>
<h4><strong>相关资料</strong>：</h4>
<ul>
	<li><a title="https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/" href="https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/">https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/</a></li>
	<li><a title="http://lesca.me/blog/2011/03/01/ssh-port-forwarding-priciple-and-praticle-application/" href="http://lesca.me/blog/2011/03/01/ssh-port-forwarding-priciple-and-praticle-application/">http://lesca.me/blog/2011/03/01/ssh-port-forwarding-priciple-and-praticle-application/</a></li>
</ul>
<p> </p>

<p> </p>

<p> </p>
]]></content>
  </entry>
  
</feed>
